# Resumen Formal del Proyecto AcadÃ©mico
## VecinoMarket â€“ VersiÃ³n AcadÃ©mica (Arquitectura de Software)

---

## 1. Contexto General

**VecinoMarket** es un proyecto acadÃ©mico desarrollado en el marco de la asignatura **Arquitectura de Software**. El objetivo principal no es construir un producto SaaS comercial, sino **diseÃ±ar y estructurar el nÃºcleo de negocio (Domain Core)** aplicando principios arquitectÃ³nicos sÃ³lidos y patrones de diseÃ±o reconocidos.

### Principios ArquitectÃ³nicos Aplicados

- **SeparaciÃ³n de responsabilidades** (Separation of Concerns)
- **Bajo acoplamiento** (Loose Coupling)
- **Principios SOLID**
- **Service Layer Pattern**
- **Patrones de diseÃ±o**: Builder, Factory, Repository
- **Independencia de framework**
- **PreparaciÃ³n para Strangler Pattern**

### TecnologÃ­a Base

La implementaciÃ³n actual estÃ¡ desarrollada en **Python puro**, sin dependencia directa de Django en el dominio. Aunque el curso posteriormente migrarÃ¡ a Django para integrar la capa web, el nÃºcleo de negocio permanece independiente del framework.

---

## 2. Problema de Negocio Modelado

El sistema modela un **marketplace privado para comunidades residenciales**, donde los residentes pueden:

- âœ… Publicar productos
- âœ… Publicar servicios
- âœ… Realizar compras
- âœ… Gestionar transacciones
- âœ… Navegar por categorÃ­as
- 

### Estado Actual de ImplementaciÃ³n

En la versiÃ³n acadÃ©mica actual:

- âœ… Dominio completo modelado
- âœ… Flujo de publicaciÃ³n implementado
- âœ… Modelo transaccional (carrito + transacciÃ³n)
- âœ… SeparaciÃ³n en capas arquitectÃ³nicas
- âœ… Validaciones de negocio en entidades
- âœ… Service Layer funcional

---

## 3. Arquitectura Adoptada

El proyecto implementa una **arquitectura por capas** (Layered Architecture) con clara separaciÃ³n de responsabilidades:

```
marketplace/
â”œâ”€â”€ domain/              # Capa de Dominio (Entidades Puras)
â”œâ”€â”€ application/         # Capa de AplicaciÃ³n (Service Layer)
â”œâ”€â”€ infrastructure/      # Capa de Infraestructura (Repositorios, Factories)
â””â”€â”€ interface/          # Capa de Interfaz (API REST con Django)
```

### 3.1 Capa de Dominio (`domain/`)

Contiene **entidades puras del negocio** que representan los conceptos fundamentales del sistema:

#### Entidades Principales

| Entidad | Responsabilidad | Archivo |
|---------|----------------|---------|
| [UnidadResidencial](file:///d:/VecinoMarket/Arq.software/marketplace/application/services.py#120-152) | Representa el conjunto residencial (edificio, torre, barrio) | [unidad_residencial.py](file:///d:/VecinoMarket/Arq.software/marketplace/domain/unidad_residencial.py) |
| `Marketplace` | Espacio de intercambio asociado a cada unidad | [marketplace.py](file:///d:/VecinoMarket/Arq.software/marketplace/domain/marketplace.py) |
| [Usuario](file:///d:/VecinoMarket/Arq.software/marketplace/application/services.py#81-118) | Residente que puede vender y comprar | [usuario.py](file:///d:/VecinoMarket/Arq.software/marketplace/domain/usuario.py) |
| [Producto](file:///d:/VecinoMarket/Arq.software/marketplace/domain/producto.py#12-106) | ArtÃ­culo fÃ­sico en venta | [producto.py](file:///d:/VecinoMarket/Arq.software/marketplace/domain/producto.py) |
| `Servicio` | Servicio ofrecido por residentes | [servicio.py](file:///d:/VecinoMarket/Arq.software/marketplace/domain/servicio.py) |
| [Categoria](file:///d:/VecinoMarket/Arq.software/marketplace/application/services.py#154-186) | ClasificaciÃ³n de productos y servicios | [categoria.py](file:///d:/VecinoMarket/Arq.software/marketplace/domain/categoria.py) |
| `Carrito` | Items seleccionados antes de comprar | [carrito.py](file:///d:/VecinoMarket/Arq.software/marketplace/domain/carrito.py) |
| `Transaccion` | Compra formalizada | [transaccion.py](file:///d:/VecinoMarket/Arq.software/marketplace/domain/transaccion.py) |

#### CaracterÃ­sticas de las Entidades de Dominio

Estas clases:

- âŒ **NO** dependen de Django
- âŒ **NO** conocen HTTP
- âŒ **NO** conocen ORM
- âœ… Contienen **reglas bÃ¡sicas de negocio**
- âœ… Implementan **validaciones de invariantes**
- âœ… Utilizan **dataclasses** de Python para inmutabilidad

#### Ejemplo: Validaciones en [Producto](file:///d:/VecinoMarket/Arq.software/marketplace/domain/producto.py#12-106)

```python
@dataclass
class Producto:
    """
    Validaciones de negocio:
    - Nombre: 5-100 caracteres
    - Precio: > 0, tipo Decimal para precisiÃ³n monetaria
    - Stock: >= 0
    - DescripciÃ³n: 10-500 caracteres (opcional)
    - ImÃ¡genes: mÃ¡ximo 10 URLs
    """
    
    def __post_init__(self):
        """Validar invariantes de negocio."""
        # Validaciones automÃ¡ticas al crear la entidad
```

---

### 3.2 Service Layer (`application/`)

Orquesta **casos de uso** del sistema, coordinando entidades y repositorios.

#### Servicios Implementados

| Servicio | Responsabilidad | Archivo |
|----------|----------------|---------|
| [UsuarioService](file:///d:/VecinoMarket/Arq.software/marketplace/application/services.py#81-118) | GestiÃ³n del ciclo de vida de usuarios | [services.py](file:///d:/VecinoMarket/Arq.software/marketplace/application/services.py) |
| [UnidadResidencialService](file:///d:/VecinoMarket/Arq.software/marketplace/application/services.py#120-152) | GestiÃ³n de unidades residenciales | [services.py](file:///d:/VecinoMarket/Arq.software/marketplace/application/services.py) |
| [CategoriaService](file:///d:/VecinoMarket/Arq.software/marketplace/application/services.py#154-186) | GestiÃ³n de categorÃ­as | [services.py](file:///d:/VecinoMarket/Arq.software/marketplace/application/services.py) |
| `PublicacionService` | OrquestaciÃ³n de publicaciÃ³n de productos | [services.py](file:///d:/VecinoMarket/Arq.software/marketplace/application/services.py) |

#### Responsabilidades del Service Layer

- âœ… Coordinar entidades
- âœ… Validar reglas de negocio complejas
- âœ… Invocar builders para construcciÃ³n de entidades
- âœ… Invocar repositories para persistencia
- âœ… Ejecutar efectos secundarios (notificaciones)
- âœ… Manejar transaccionalidad

#### Ejemplo: `PublicacionService.publicar_producto()`

```python
def publicar_producto(self, cmd: PublicarProductoCommand) -> Producto:
    # 1. Buscar vendedor
    vendedor = self.usuario_repo.get(cmd.vendedor_id)
    
    # 2. Buscar categorÃ­a
    categoria = self.categoria_repo.get(cmd.categoria_id)
    
    # 3. Verificar permisos
    if cmd.vendedor_status != "APPROVED":
        raise PermissionError("Solo usuarios APPROVED pueden publicar.")
    
    # 4. Construir producto usando Builder
    producto = (ProductoBuilder(max_images=self.max_images)
                .vendedor(vendedor)
                .categoria(categoria)
                .nombre(cmd.nombre)
                .descripcion(cmd.descripcion)
                .precio_cop(cmd.precio_cop)
                .build())
    
    # 5. Persistir
    self.producto_repo.add(producto)
    
    # 6. Notificar (side effect)
    notifier = NotifierFactory.create()
    notifier.notify_listing_created(vendedor.telefono, producto.nombre)
    
    return producto
```

> [!IMPORTANT]
> El Service Layer evita que la lÃ³gica de negocio quede dispersa en las vistas (controllers), manteniendo el principio de **Single Responsibility**.

---

### 3.3 Patrones de DiseÃ±o Implementados

#### ğŸ—ï¸ Builder Pattern

**UbicaciÃ³n**: [domain/builders.py](file:///d:/VecinoMarket/Arq.software/marketplace/domain/builders.py)

**Objetivo**:
- Validar antes de crear entidades complejas
- Evitar objetos en estados inconsistentes
- Separar construcciÃ³n de uso
- Aplicar validaciones especÃ­ficas del proceso de publicaciÃ³n

**ImplementaciÃ³n**: [ProductoBuilder](file:///d:/VecinoMarket/Arq.software/marketplace/domain/builders.py#9-88)

```python
class ProductoBuilder:
    """
    Builder para crear productos con validaciones.
    Validaciones especÃ­ficas del proceso de publicaciÃ³n.
    """
    
    def __init__(self, max_images: int = 4):
        self.max_images = max_images
        # ... campos privados
    
    def vendedor(self, u: Usuario):
        self._vendedor = u
        return self
    
    def build(self) -> Producto:
        # Validaciones de negocio antes de crear
        if not (1_000 <= self._precio_cop <= 50_000_000):
            raise ValidationError("Precio COP debe estar entre 1.000 y 50.000.000.")
        
        return Producto(...)
```

#### ğŸ­ Factory Pattern

**UbicaciÃ³n**: [infrastructure/factories.py](file:///d:/VecinoMarket/Arq.software/marketplace/infrastructure/factories.py)

**Objetivo**:
- Desacoplar infraestructura externa (ej. notificaciones)
- No depender directamente de implementaciones concretas
- Permitir cambio segÃºn entorno (dev vs prod)

**ImplementaciÃ³n**: [NotifierFactory](file:///d:/VecinoMarket/Arq.software/marketplace/infrastructure/factories.py#3-7)

```python
class NotifierFactory:
    @staticmethod
    def create():
        # En dev: ConsoleNotifier
        # En prod: podrÃ­a ser SMSNotifier, EmailNotifier, etc.
        return ConsoleNotifier()
```

#### ğŸ“¦ Repository Pattern

**UbicaciÃ³n**: [infrastructure/repositories.py](file:///d:/VecinoMarket/Arq.software/marketplace/infrastructure/repositories.py)

**Objetivo**:
- Desacoplar persistencia del dominio
- Permitir migraciÃ³n futura a ORM sin modificar lÃ³gica de negocio
- Facilitar testing con repositorios en memoria

**ImplementaciÃ³n**: Repositorios en memoria

```python
class InMemoryProductoRepository:
    def __init__(self):
        self.db = {}
    
    def add(self, producto: Producto):
        self.db[producto.id] = producto
    
    def get(self, id: str) -> Optional[Producto]:
        return self.db.get(id)
    
    def list_all(self) -> List[Producto]:
        return list(self.db.values())
```

> [!NOTE]
> Los repositorios en memoria permiten testear el dominio sin dependencias externas y facilitan la migraciÃ³n futura a Django ORM o cualquier otra tecnologÃ­a de persistencia.

---

### 3.4 Capa de Infraestructura (`infrastructure/`)

Contiene implementaciones concretas de abstracciones del dominio:

| Componente | PropÃ³sito | Archivo |
|------------|-----------|---------|
| Repositories | Persistencia en memoria (preparado para ORM) | [repositories.py](file:///d:/VecinoMarket/Arq.software/marketplace/infrastructure/repositories.py) |
| Factories | CreaciÃ³n de dependencias externas | [factories.py](file:///d:/VecinoMarket/Arq.software/marketplace/infrastructure/factories.py) |
| Notifiers | Implementaciones de notificaciones | [notifier.py](file:///d:/VecinoMarket/Arq.software/marketplace/infrastructure/notifier.py) |

---

### 3.5 Capa de Interfaz (`interface/`)

Expone el dominio a travÃ©s de una **API REST** usando Django REST Framework:

| Componente | PropÃ³sito | Archivo |
|------------|-----------|---------|
| Views | Controllers REST | [views.py](file:///d:/VecinoMarket/Arq.software/marketplace/interface/views.py) |
| Serializers | TransformaciÃ³n de datos | [serializers.py](file:///d:/VecinoMarket/Arq.software/marketplace/interface/serializers.py) |
| URLs | Rutas de la API | [urls.py](file:///d:/VecinoMarket/Arq.software/marketplace/interface/urls.py) |

> [!WARNING]
> La capa de interfaz **NO** contiene lÃ³gica de negocio. Solo transforma datos y delega al Service Layer.

---

## 4. Independencia de Framework

El diseÃ±o del dominio es **completamente independiente de Django**.

### âŒ No existen referencias a:

- `HttpRequest` / `HttpResponse`
- `django.db.models.Model`
- `django.views.View`
- ORM de Django
- Decorators de framework

### âœ… Esto permite:

- **Testear dominio aislado** sin levantar Django
- **Migrar infraestructura** sin romper negocio
- **Aplicar Strangler Pattern** en el futuro
- **Reutilizar dominio** en otros contextos (CLI, microservicios, etc.)

---

## 5. Estado Actual del Proyecto AcadÃ©mico

### âœ… Implementado

- [x] Modelo de dominio completo
- [x] Service Layer funcional
- [x] Builder Pattern ([ProductoBuilder](file:///d:/VecinoMarket/Arq.software/marketplace/domain/builders.py#9-88))
- [x] Factory Pattern ([NotifierFactory](file:///d:/VecinoMarket/Arq.software/marketplace/infrastructure/factories.py#3-7))
- [x] Repository Pattern (In-Memory)
- [x] Validaciones de negocio en entidades
- [x] Demo ejecutable en Python puro
- [x] API REST con Django (capa de interfaz)
- [x] SeparaciÃ³n clara de capas

### ğŸ“‹ Estructura de Archivos

```
marketplace/
â”œâ”€â”€ domain/
â”‚   â”œâ”€â”€ usuario.py              # Entidad Usuario
â”‚   â”œâ”€â”€ unidad_residencial.py   # Entidad UnidadResidencial
â”‚   â”œâ”€â”€ marketplace.py          # Entidad Marketplace
â”‚   â”œâ”€â”€ producto.py             # Entidad Producto
â”‚   â”œâ”€â”€ servicio.py             # Entidad Servicio
â”‚   â”œâ”€â”€ categoria.py            # Entidad Categoria
â”‚   â”œâ”€â”€ carrito.py              # Entidad Carrito
â”‚   â”œâ”€â”€ transaccion.py          # Entidad Transaccion
â”‚   â”œâ”€â”€ builders.py             # Builder Pattern
â”‚   â””â”€â”€ exceptions.py           # Excepciones de dominio
â”‚
â”œâ”€â”€ application/
â”‚   â””â”€â”€ services.py             # Service Layer
â”‚
â”œâ”€â”€ infrastructure/
â”‚   â”œâ”€â”€ repositories.py         # Repository Pattern
â”‚   â”œâ”€â”€ factories.py            # Factory Pattern
â”‚   â””â”€â”€ notifier.py             # Implementaciones de notificaciÃ³n
â”‚
â”œâ”€â”€ interface/
â”‚   â”œâ”€â”€ views.py                # API REST Controllers
â”‚   â”œâ”€â”€ serializers.py          # DTOs de entrada/salida
â”‚   â””â”€â”€ urls.py                 # Rutas de la API
â”‚
â””â”€â”€ demo_script.py              # Demo ejecutable
```

---

## 6. Enfoque ArquitectÃ³nico del Curso

El curso estÃ¡ guiando el proceso evolutivo desde:

1. **Monolito desorganizado** (spaghetti code)
2. **Monolito limpio** aplicando SOLID
3. **IntroducciÃ³n de Service Layer**
4. **Desacoplamiento real** (independencia de framework)
5. **PreparaciÃ³n para patrÃ³n Strangler**
6. **Posible futura extracciÃ³n** a servicios externos

> [!TIP]
> VecinoMarket fue diseÃ±ado **directamente con mentalidad de desacoplamiento**, reduciendo significativamente el refactor futuro.

---

## 7. DiferenciaciÃ³n Importante

### ğŸ“ Esta versiÃ³n es acadÃ©mica

Aunque el concepto puede escalar a SaaS multi-tenant, en el contexto del curso:

- âœ… El enfoque estÃ¡ en **diseÃ±o arquitectÃ³nico**
- âŒ No se expone modelo comercial real
- âŒ No se detallan estrategias de monetizaciÃ³n
- âŒ No se incluyen decisiones empresariales

**El Ã©nfasis es tÃ©cnico y estructural.**

---

## 8. Objetivo del Semestre

Construir un **nÃºcleo de negocio**:

- âœ… **Testeable**: Sin dependencias externas
- âœ… **Desacoplado**: Independiente del framework
- âœ… **Escalable**: Preparado para crecimiento
- âœ… **Modular**: SeparaciÃ³n clara de responsabilidades
- âœ… **Independiente del framework**: Dominio puro

### Demostrar comprensiÃ³n de:

1. **Principios SOLID**
   - Single Responsibility (cada servicio una responsabilidad)
   - Open/Closed (extensible sin modificar)
   - Liskov Substitution (polimorfismo en repositorios)
   - Interface Segregation (interfaces especÃ­ficas)
   - Dependency Inversion (depender de abstracciones)

2. **Service Layer Pattern**
   - OrquestaciÃ³n de casos de uso
   - SeparaciÃ³n de lÃ³gica de negocio y presentaciÃ³n

3. **InversiÃ³n de dependencias**
   - Dominio no depende de infraestructura
   - Infraestructura implementa abstracciones del dominio

4. **SeparaciÃ³n de dominio e infraestructura**
   - Dominio puro sin dependencias externas
   - Infraestructura intercambiable

5. **DiseÃ±o orientado a evoluciÃ³n**
   - Preparado para Strangler Pattern
   - MigraciÃ³n incremental a microservicios

---

## 9. DemostraciÃ³n Funcional

El proyecto incluye un script de demostraciÃ³n ejecutable que muestra el flujo completo:

**Archivo**: [demo_script.py](file:///d:/VecinoMarket/Arq.software/marketplace/demo_script.py)

### Flujo de la Demo

1. âœ… Crear Unidad Residencial
2. âœ… Crear Marketplace asociado
3. âœ… Registrar categorÃ­as
4. âœ… Registrar residentes/usuarios
5. âœ… Publicar productos
6. âœ… Publicar servicios
7. âœ… Agregar items al carrito
8. âœ… Crear transacciÃ³n desde el carrito
9. âœ… Realizar bÃºsquedas

### EjecuciÃ³n

```bash
python marketplace/demo_script.py
```

---

## 10. ConclusiÃ³n

**VecinoMarket** es un proyecto acadÃ©mico que demuestra la aplicaciÃ³n prÃ¡ctica de principios arquitectÃ³nicos sÃ³lidos en un contexto de negocio realista. La implementaciÃ³n actual refleja:

- ğŸ—ï¸ **Arquitectura limpia** con separaciÃ³n de capas
- ğŸ¯ **Patrones de diseÃ±o** aplicados correctamente
- ğŸ”§ **Independencia de framework** para flexibilidad futura
- ğŸ“š **PreparaciÃ³n para evoluciÃ³n** arquitectÃ³nica

El proyecto sirve como base sÃ³lida para futuras extensiones, ya sea hacia un SaaS multi-tenant o hacia una arquitectura de microservicios, manteniendo siempre el nÃºcleo de negocio intacto y desacoplado.

---

**Autor**: Proyecto AcadÃ©mico - Arquitectura de Software  
**Fecha**: Febrero 2026  
**VersiÃ³n**: AcadÃ©mica (Pre-SaaS)
